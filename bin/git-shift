#!/usr/bin/env perl
#
# git-shift - shifts timestamps of commits after the fact
#
# Copyright (c) 2010, 2012, 2013 Akinori MUSHA
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#

use strict;
use warnings;
use Getopt::Long;
use IO::Select;
use IPC::Open3;
use POSIX qw(tzset tzname);
use Symbol 'gensym';
use Time::Local;
use Time::Piece 1.16;	# timezone support is required
use Time::Seconds;

my($opt_v, $opt_n, $opt_k);
my $exit_status = 0;

sub usage {
    print STDERR <<'EOS';
usage: git shift [options] {[<time>][<timediff>][timezone]|<datetime>} <rev-list>...

    -v, --verbose         be verbose
    -n, --dry-run         dry run
    -k                    skip errors

    <timediff>            add this time span to current commit time(s)
                          in regexp: /^[-+]([0-9]+[wdhms])+$/
                          e.g.
                            +1d -12h 30m -1h30m -600s

    <time>                substitute this value for the time part(s) of
                          current commit time(s)
                          one of:
                            - "HH:MM:SS"
                            - "HH:MM" (= "HH:MM:00")

    <timezone>            specify the time zone offset
                          in regexp: /^[-+][01][0-9][0-5][0-9]$/

    <datetime>            set this date time as commit time(s)
                          one of:
                            - ISO-8601 date time string
                            - date(1) format in C locale
                            - number of seconds since the Unix epoch

    <rev-list>            speficy commits to modify which must be on the
                          current branch; a single commit <committish> or
                          a range of commits <committish1>..<committish2>
                          (*both inclusive*)
EOS
}

sub main {
    Getopt::Long::Configure qw(no_getopt_compat require_order pass_through);
    GetOptions("h|help"    => sub { usage(); exit },
               "v|verbose" => \$opt_v,
               "n|dry-run" => \$opt_n,
               "k"         => \$opt_k) or exit 64;
    pop @ARGV if @ARGV && $ARGV[$#ARGV] eq '--';
    $opt_v = 1  if $opt_n;

    if (!@ARGV) {
        usage();
        exit 129;
    }

    my($timespec, @revspec) = @ARGV;
    my $function = parse_timespec($timespec);

    if (!defined($function)) {
        print STDERR "$0: error in time spec.\n";
        usage();
        exit 129;
    }

    git_shift($function, @revspec);

    exit $exit_status;
}

sub may_exit {
    my($status) = @_ ? @_ : ($? >> 8);
    exit $status unless $opt_k;
    $exit_status = $status;
}

sub git_shift {
    my($function, @revspec) = @_;

    if (`git diff --shortstat` =~ /\w/) {
        print STDERR "$0: work directory is not clean.\n";
        exit 1;
    }
    if (`git diff --shortstat --cached` =~ /\w/) {
        print STDERR "$0: index is not clean.\n";
        exit 1;
    }

    my %revs = map { ($_ => 0) } map { expand_revspec($_) } @revspec;

    if (!%revs) {
        print STDERR "$0: no revision specified\n";
        exit 64;
    }

    my(%rev_info, @all_revs, $start, $found);

    my $git = open3(my $in, my $out, '>&2',
                    'git', 'log', '--reverse',
                    '--date=raw', '--pretty=format:%H %ad %cd') or die $!;
    for my $line (<$out>) {
        my($rev, @rev_info) = split(' ', $line);
        if (exists($revs{$rev})) {
            $revs{$rev}++;
            $found ||= do {
                if (!$start) {
                    print STDERR "$0: cannot modify the root commit.\n";
                    exit 1;
                }
                1;
            };
        }
        if ($found) {
            push @all_revs, $rev;
            $rev_info{$rev} = \@rev_info;
        } else {
            $start = $rev
        }
    }
    waitpid $git, 0;
    exit($? >> 8) if $?;

    for my $rev (keys(%revs)) {
        if (!$revs{$rev}) {
            print STDERR "$0: can only modify commits on the current branch.\n";
            exit 1;
        }
    }

    unless ($opt_n) {
        system 'git', 'reset', '--hard', $start;
        exit($? >> 8) if $?;
    }

    my $keep_prev_reflog = 1;

    for my $rev (@all_revs) {
        my($atime, $atz, $ctime, $ctz) = @{$rev_info{$rev}};
        my $changed;
        if (exists($revs{$rev})) {
            my($ntime, $ntz) = $function->($atime, $atz);

            my($atimestr, $ctimestr, $ntimestr) = map {
                stringify_git_time(@$_);
            } ([$atime, $atz], [$ctime, $ctz], [$ntime, $ntz]);

            print "AuthorDate: $atimestr\n";
            print "CommitDate: $ctimestr\n";
            print "         => $ntimestr\n";

            $atime = $ctime = $ntime;
            $atz   = $ctz   = $ntz;
            $changed = 1;
        }

        git_cherry_pick($rev, $atime, $atz, $ctime, $ctz);

        delete_prev_reflog() unless $keep_prev_reflog;

        $keep_prev_reflog = $changed;
    }
}

sub git_revlist {
    my $git = open3(my $in, my $out, '>&2',
                    'git', 'rev-list', @_) or die $!;
    my @out = <$out>;
    waitpid $git, 0;
    exit($? >> 8) if $?;
    chomp(@out);
    @out;
}

sub git_cherry_pick {
    my($rev, $atime, $atz, $ctime, $ctz) = @_;

    return if $opt_n;

    system "git cherry-pick $rev >/dev/null";
    exit($? >> 8) if $?;

    local $ENV{GIT_COMMITTER_DATE} = "$ctime $ctz";
    system 'git', 'commit', '--amend',
        "--date=$atime $atz", '-C', $rev;
    exit($? >> 8) if $?;

    delete_prev_reflog();
}

sub delete_prev_reflog {
    return if $opt_n;

    system 'git', 'reflog', 'delete', 'HEAD@{1}';
}

sub expand_revspec {
    my($revspec, $branch) = @_;
    @_ == 1 or die;

    if ($revspec =~ /\.\.\./) {
        print STDERR "$0: `...' is not supported.\n";
        exit 64;
    }
    if ($revspec =~ /\.\./) {
        my($from_spec, $to_spec) = split(/\.\./, $revspec, 2);
        if ($to_spec eq '') {
            $to_spec = 'HEAD';
        }
        return git_revlist($from_spec eq '' ?
                               $to_spec :
                                   sprintf('%s^..%s', $from_spec, $to_spec));
    }

    my $git = open3(my $in, my $out, '>&2',
                    'git', 'rev-parse', $revspec) or die $!;
    my($rev, @rest) = <$out>;
    waitpid $git, 0;
    exit($? >> 8) if $?;
    if (@rest || $rev !~ /^[0-9a-f]{40}$/) {
        print STDERR "$0: $revspec does not specify a valid commit.\n";
        exit 64;
    }
    chomp($rev);
    ($rev);
}

my $re_epoch	= qr/(?:0|[1-9][0-9]*)/;
my $re_tz	= qr/[-+][01][0-9][0-5][0-9]/;
my $re_span	= qr/[-+](?:[0-9]+[wdhms])+/;

sub parse_timespec {
    my($timespec) = @_;
    if ($timespec =~ /\A($re_epoch)($re_tz)?\z/o) {
        my($ntime, $ntz) = ($1, $2);
        return sub {
            my($otime, $otz) = @_;
            ($ntime, defined($ntz) ? $ntz : $otz);
        };
    } elsif ($timespec =~ /\A(?=.)(([0-9]{2}):([0-9]{2})(?::([0-9]{2}))?)?($re_span)?($re_tz)?\z/o) {
        my($hhmmss, $hh, $mm, $ss, $span, $ntz) = ($1, $2, $3, $4, $5, $6);
        return sub {
            my($otime, $otz) = @_;
            if (defined($span) && defined(my $seconds = parse_timediff($span))) {
                $otime += $seconds;
            }
            if (defined($hhmmss)) {
                $otime -= ($otime + parse_tz($otz)) % ONE_DAY;
                $otime += $hh * ONE_HOUR + $mm * ONE_MINUTE + ($ss || 0);
            }
            ($otime, defined($ntz) ? $ntz : $otz);
        };
    } else {
        my($time, $tzoffset) = eval {
            parse_date($timespec);
        };
        return sub {
            ($time->epoch, stringify_tzoffset($tzoffset));
        } unless $@;
    }

    return undef;
}

sub parse_date {
    my($datetime) = @_;
    my($time, $tzoffset);

    if ($datetime =~ /\A([0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2})(Z|[-+][0-9]{4})?\z/){
        my($date, $tzsuffix) = ($1, $2);
        eval {
            if (!defined($tzsuffix)) {
                $time = localtime(Time::Piece->strptime($date, '%Y-%m-%dT%T'));
                $tzoffset = $time->tzoffset;
            } elsif ($tzsuffix eq 'Z') {
                $time = Time::Piece->strptime($date, '%Y-%m-%dT%T');
                $tzoffset = 0;
            } else {
                $time = Time::Piece->strptime($datetime, '%Y-%m-%dT%T%z');
                $tzoffset = parse_tz($tzsuffix);
            }
        };
        return ($time, $tzoffset) unless $@;
    };

    if ($datetime =~ /\A([A-Z][a-z]+\s+[A-Z][a-z]+\s+[0-9]{1,2}\s+[0-9]{2}:[0-9]{2}:[0-9]{2})\s+(?:UTC|GMT|([A-Z]+))\s+([0-9]+)\z/) {
        my($date, $tzname, $year) = ($1, $2, $3);
        eval {
            my @localtzname = grep { !/\A(UTC|GMT|WILDABBR)\z/ } do {
                POSIX::tzset();
                POSIX::tzname();
            };
            $time = Time::Piece->strptime("$date $year", '%a %b %d %T %Y');
            if (defined($tzname)) {
                grep { $_ eq $tzname } @localtzname or die 'unrecognized time zone name';
                $time = localtime(
                    timelocal($time->sec, $time->min, $time->hour,
                              $time->mday, $time->_mon, $time->year)
                );
                $tzoffset = $time->tzoffset;
            } else {
                $tzoffset = 0;
            }
        };
        return ($time, $tzoffset) unless $@;
    }

    die 'unrecognized date format';
}


sub parse_timediff {
    my($spec) = @_;
    my $value = 0;
    my $sign = ($spec =~ s/\A([-+])//) && $1;
    until ($spec eq '') {
        if ($spec =~ s/\A([0-9]+)([wdhms])//) {
            my $seconds = $1 * (
                $2 eq 'w' ? ONE_WEEK :
                $2 eq 'd' ? ONE_DAY :
                $2 eq 'h' ? ONE_HOUR :
                $2 eq 'm' ? ONE_MINUTE :
                1
            );
            if ($sign eq '-') {
                $value -= $seconds;
            } else {
                $value += $seconds;
            }
        } else {
            return undef;
        }
    }
    $value;
}

sub parse_tz {
    my($tz) = @_;
    my $t = gmtime();
    my $u = Time::Piece->strptime(
        $t->strftime("%Y-%m-%dT%H:%M:%S$tz"),
        '%Y-%m-%dT%H:%M:%S%z'
    );
    $t - $u;
}

sub stringify_tzoffset {
    my($tzo) = @_;
    my $min = $tzo % ONE_HOUR;
    my $hour = ($tzo - $min) / ONE_HOUR;
    sprintf('%+03d%02d', $hour, $min);
}

sub stringify_git_time {
    my($time, $tz) = @_;
    my $t = gmtime($time) + parse_tz($tz);
    $t->strftime("%a %b %d %T %Y") . " $tz";
}

main();
